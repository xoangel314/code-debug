首先根据arceos主页安装`cargo-binutils` `libclang-dev` `cross-musl-based` 等工具。
然后我们安装riscv64,x86_64,aarch64虚拟机：
```shell
cd qemu-7.0.0/
./configure --target-list=aarch64-softmmu,riscv64-softmmu,x86_64-softmmu,aarch64-linux-user,aarch64_be-linux-user,riscv64-linux-user,x86_64-linux-user
make -j$(nproc)
```
在你的终端配置文件中添加：
```
export PATH=$PATH:/home/oslab/qemu-7.0.0/build
```
然后重启终端。我们之前已经运行过riscv的了(<https://github.com/rcore-os/blog/pull/228/files>)，因此尝试运行x86_64：
```
make A=./apps/helloworld/ ARCH=x86_64 LOG=info run
```
遇到错误：
```
    Running on qemu...
qemu-system-x86_64 -m 128M -smp 1 -machine q35 -kernel ./apps/helloworld//helloworld_x86_64-qemu-q35.elf -nographic -cpu host -accel kvm
Could not access KVM kernel module: No such file or directory
qemu-system-x86_64: -accel kvm: failed to initialize kvm: No such file or directory
make: *** [Makefile:162: justrun] Error 1

```
原因是我的Linux是跑在VMWare虚拟机里的，不支持KVM. 因此去掉`-cpu host -accel kvm`参数:
```
qemu-system-x86_64 -m 128M -smp 1 -machine q35 -kernel ./apps/helloworld/helloworld_x86_64-qemu-q35.elf -nographic
```

运行成功. 接着我们把这个qemu启动参数搬到 `launch.json` 里. 由于这里qemu直接启动elf而不是bin文件，`launch.json`也做对应的调整：
```json

   //launch.json
   {
    "version": "0.2.0",
    "configurations": [
        {
            "type": "gdb",
            "request": "launch",
            "name": "Attach to Qemu",
            "executable": "${userHome}/arceos/apps/helloworld/helloworld_x86_64-qemu-q35.elf",
            "target": ":1234",
            "remote": true,
            "cwd": "${workspaceRoot}",
            "valuesFormatting": "parseText",
            "gdbpath": "gdb-multiarch",
            "showDevDebugOutput":true,
            "internalConsoleOptions": "openOnSessionStart",
            "printCalls": true,
            "stopAtConnect": true,
            "qemuPath": "qemu-system-x86_64",
            "qemuArgs": [
                "-M",
                "128m",
                "-smp",
                "1",
                "-machine",
                "q35",
                "-kernel",
                "apps/helloworld/helloworld_x86_64-qemu-q35.bin",
                "-nographic",
                "-s",
                "-S"
            ],

         "KERNEL_IN_BREAKPOINTS_LINE":65, // src/trap/mod.rs中内核入口行号。可能要修改
         "KERNEL_OUT_BREAKPOINTS_LINE":124, // src/trap/mod.rs中内核出口行号。可能要修改
         "GO_TO_KERNEL_LINE":30, // src/trap/mod.rs中，用于从用户态返回内核的断点行号。在rCore-Tutorial-v3中，这是set_user_trap_entry函数中的stvec::write(TRAMPOLINE as usize, TrapMode::Direct);语句。
        },
    ]
}
```

arceos-httpserver也跑通了。只需要注意qemu开放的tcp端口不要和gdb占用的端口有重叠即可。